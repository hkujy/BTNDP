! LINK BASED DOUBLE PROJECTION LARGE NETWORK

!	INCLUDE 'MSA&SAM.f90'
!	INCLUDE 'GetMSAFx.F90'

		SUBROUTINE SAMMAIN(TAU,LAMA,NCPERR,CPUTIME,DistanceErr)
		USE  GRAPH
		IMPLICIT NONE 
		! IN THE MSA THE FLOW THE VARIABLE DRRECTILY 
		REAL*8,INTENT(OUT)::CPUTIME,DistanceErr
		REAL*8,INTENT(IN)::TAU,LAMA ! TAU IS LARGE VALUE, LAMA IS SMALL VALUE
		REAL*8::X0(NL,NDEST),X1(NL,NDEST),X2(NL,NDEST)
		REAL*8::FX0(NL,NDEST),FX1(NL,NDEST),BETA,MSAERR
		REAL*8,INTENT(OUT)::NCPERR
		REAL*8::LT(NL),LF(NL),NCPFX(NL,NDEST)
		INTEGER I
		INTEGER,ALLOCATABLE::FIRSTOUT(:),LASTOUT(:)
		LOGICAL:: CONVERT,DEL
		REAL*8 ET,ST
		INTEGER SUBCOUNTER
!	REAL*8 ST,ET   ! START TIME AND END TIME  CUMULATIVE TIME
!	INTEGER SC ! COUNT NUMBER OF SOLUTIONS
	! STEP 1 READ DATA AND BUILD TREE	
		ALLOCATE(FIRSTOUT(NL),LASTOUT(NL))
		SAM = .TRUE.
		CALL READ_DATA(FIRSTOUT,LASTOUT)
!...........................................................
		OPEN(7,FILE='..\RESULTS\SAMCONVERGE.TXT')
		WRITE(7,*) "*******************************************"
		WRITE(7,*) "TAU = ",TAU,"LAMA = ", LAMA
		WRITE(7,*) "*******************************************"

		PITER = 0
		CALL CPU_TIME(TIME_BEGIN)
		CALL CPU_TIME(ST)
!		WRITE(7,*) "st=",ST
		BETA=1.0D0
		X1=0.0
		FX1=0.0
		X2=0.0
		CALL MINSP(X0)
		CALL GETORDER(SCOST)
		CALL COUNTCONECT
		!CALL SHORTEST_PATH_UPDATE_FX(SCOST,X0)  !INITIAL BASED ON SHORTEST PATH
		
		FORALL (I = 1:NL)
			LF(I)=SUM(X0(I,:))
		END FORALL	

		CALL LINK_TIME(LF,LT)
		DEL = .FALSE.
		CALL UPDATESUB(LT,DEL,X1)
		SUBCOUNTER = 0
		CALL BACKWARD_UPDATE_FX(NCPFX,LT)
		!CALL BACKWARD_UPDATE_FX(NCPFX,LT)
!		CALL NCP_ERROR(X0,NCPFX,NCPERR)
		CALL NCP_ERROR(NCPERR,X0,NCPFX)
		WRITE(7,'(I4,2X,F14.6)') SOLC,NCPERR
		SOLC = SOLC+1

!		CALL CPU_TIME(ET)
	!	WRITE(7,*) SOLC,NCPERR
	!	WRITE(7,*) SC,NCPERR
		CALL CAL_MSA_FX(FX0,LT) ! CORRESPONDING FX
! COMPUTE ERROR OF INITIAL ASSIGNMENT 
! THIS ERROR SHOULD BE EQUAL WITH THAT OF DP METHOD 
	

!***********block to calculate the error of the first iteration	
		X1=FX0
		FORALL (I = 1:NL)
			LF(I)=SUM(X1(I,:))
		END FORALL
		CALL LINK_TIME(LF,LT)
		CALL CAL_MSA_FX(FX1,LT)
!******************************************************************
5		CALL SELF_REGULATED_MSA(X0,X1,FX0,FX1,X2,NL,NDEST,BETA,TAU,LAMA,CONVERT,MSAERR)
		SUBCOUNTER = SUBCOUNTER + 1
		!DO I=1,NL
		FORALL (I = 1: NL)
			LF(I)=SUM(X2(I,:))
		END FORALL 
		!END DO 
		CALL LINK_TIME(LF,LT)
!		CALL BACKWARD_UPDATE_FX(NCPFX,LT)
		CALL BACKWARD_UPDATE_FX(NCPFX,LT)
	!	PITER = PITER + 1	
	!	CALL MSA_NCP_ERROR(X2,NCPFX,NCPERR)
		CALL NCP_ERROR(NCPERR,X2,NCPFX)
        CALL ERROR_Euclidean_distance(X2,X1,NL,NDEST,DistanceErr)
        
    !   WRITE(*,'(I4,2X,F14.6,2X,F10.6)') SOLC,NCPERR,DistanceErr
	!	WRITE(7,'(I4,2X,F14.6,2X,F10.3)') SOLC,NCPERR,DistanceErr
		CALL CPU_TIME(ET)
		SOLC = SOLC +1
		WRITE(7,*) SOLC,NCPERR,DistanceErr
		IF (NCPERR<=NCP_EPS.OR.(ET-TIME_BEGIN).GT.MAXCPU.OR.(SUBCOUNTER.GT.SUBMAX)) GOTO 1000
	!	IF (NCPERR<=NCP_EPS.OR.SOLC.GE.MACSOLC)	GOTO 1000
		X0=X1
		FX0=FX1
		X1=X2
		X2=0.0

		CALL CAL_MSA_FX(FX1,LT)
	 GOTO 5

1000	CALL CPU_TIME(TIME_END)
		CPUTIME=TIME_END-TIME_BEGIN
		DEL = .TRUE.
		IF (NCPERR<=NCP_EPS.OR.(ET-TIME_BEGIN).GT.MAXCPU.OR.(SOLC.GT.MACSOLC)) RETURN
	!	CALL UPDATESUB(LT,DEL,X2)
		IF (.NOT.UECONVERGE) THEN
			SUBCOUNTER = 0
			X0=X1
			FX0=FX1
			X1=X2
			X2=0.0
			CALL CAL_MSA_FX(FX1,LT)
!			CALL BACKWARD_UPDATE_FX(FX,STT) 
!			CALL BACKWARD_UPDATE_FX(NCPFX,LT)
		!	WRITE(*,*) "UPDATE NEWORK"
		!	PAUSE
			GO TO 5
		ELSE 
			IF (NCPERR<=NCP_EPS.OR.(ET-TIME_BEGIN).GT.MAXCPU) THEN 
				CLOSE(7)
				RETURN 
			ELSE 
				GO TO 5
			END IF
		END IF 

		CLOSE(7)


		DEALLOCATE(FIRSTOUT,LASTOUT)

		RETURN 	
		END SUBROUTINE 
	
