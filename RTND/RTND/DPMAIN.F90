    ! LINK BASED DOUBLE PROJECTION LARGE NETWORK

    !INCLUDE 'WRITEOUTPUT.F90'

    SUBROUTINE DPMAIN(BETA,LAMA,V,MIU,ERR,CPUTIME,&
        BETASTEP,DISTANCEERR,FIRSTOUT,LASTOUT,XFA)
    USE  GRAPH
    IMPLICIT NONE
    INTEGER I

    REAL*8::ALPH
    REAL*8::NUMERATOR,DENOMINATOR
    REAL*8::EU(NL,NDEST),DU(NL,NDEST)
    REAL*8::X_BAR(NL,NDEST),FX_BAR(NL,NDEST)
    REAL*8::NORM_VALUE2
    REAL*8,INTENT(OUT)::ERR,DISTANCEERR
    REAL*8,INTENT(OUT)::CPUTIME
    REAL*8,INTENT(INOUT)::BETA,LAMA,V,MIU
    INTEGER, INTENT(IN)::FIRSTOUT(NN), LASTOUT(NN)
    REAL*8::UPDATE_ALPH
    INTEGER SUBCOUNTER
    LOGICAL DEL
    REAL*8 BETASTEP,R
    REAL*8,INTENT(Out)::XFA(NL,NDEST)
    REAL*8 XFA_OLD(NL,NDEST)
    REAL*8 ST,ET,LF(NL)
    !	REAL*8::LF(NL)  ! THIS IS LINK FLOW AND LINK TIME
    !	INTEGER(4) ETCOUNT,ETCOUNTRATE,ETCOUNTMAX



    OPEN(7,FILE='..\..\RESULTS\FORTRAN_DPCONVERGE.TXT')


    !WRITE(*,*) "FINISH TREE DATA"

    CALL CPU_TIME(TIME_BEGIN)
    CALL CPU_TIME(ST)
    SOLC = 0

    ! START MAIN ALGORITHM
    ! ASSIGN FLOW TO SHORTEST PATH
    ! STEP 0 INITIAL SHORTESTPATH TREE
    CALL MINSP(XFA)
    CALL GETORDER(SCOST)
    CALL COUNTCONECT
    CALL INITIAL_X(XFA,FIRSTOUT,LASTOUT)
    FORALL(I=1:NL)
        LF(I)=SUM(XFA(I,:))
    END FORALL
    CALL LINK_TIME(LF,STT)
    DEL = .FALSE.
    CALL UPDATESUB(STT,DEL,XFA)
    SUBCOUNTER = 0
    CALL BACKWARD_UPDATE_FX(FX,STT)
    CALL NCP_ERROR(ERR,XFA,FX)
    WRITE(7,'(I3,A,I4,A,F14.2)') CASEINDEX,',', SOLC,',',ERR
    CALL CPU_TIME(ET)
    !WRITE(7,*) SOLC,ERR
    !WRITE(*,*) SOLC,ERR
    !	WRITE(7,'(F8.6,2X,F8.4)') ET - ST , ERR
    !	WRITE(7,'(F8.6,A,F8.4)') ET - ST , ',',ERR
    ! STEP 1 PROJECTION
10  CALL PROJECTION(X_BAR,X,FX,BETA,FIRSTOUT,LASTOUT)
    XFA_OLD=XFA
    CALL CAL_FX(X_BAR,FX_BAR,XFA,FIRSTOUT,LASTOUT)
    SUBCOUNTER = SUBCOUNTER + 1
    CALL NCP_ERROR(ERR,XFA,FX)
    !CALL ERROR_EUCLIDEAN_DISTANCE(XFA,XFA_OLD,NL,NDEST,DISTANCEERR)

    CALL CPU_TIME(ET)
    SOLC = SOLC + 1
    !WRITE(*,'(I4,2X,F14.6,2X,F10.6)') SOLC,ERR,DISTANCEERR
    !WRITE(7,'(I4,2X,F14.6,2X,F10.6)') SOLC,ERR,DISTANCEERR
    WRITE(7,'(I3,A,I4,A,F14.6,A,F14.6)') CASEINDEX,',',SOLC,',',ERR,',',DISTANCEERR
    !	WRITE(7,'(F8.6,2X,F8.4)') ET - ST , ERR
    ! STEP 2 COMPARE AND UPDATE
20  NUMERATOR=NORM_VALUE2(X,X_BAR,NL,NDEST)
    DENOMINATOR=NORM_VALUE2(FX,FX_BAR,NL,NDEST)
    IF (NUMERATOR.EQ.0) THEN
        WRITE(*,*) "NUMERATOR = 0, NCPERR = ", ERR 
        IF (ERR.LE.NCP_EPS) THEN
            GOTO 1000
        ELSE
            GOTO 998
        ENDIF
        !				PAUSE
    END IF
    R=BETA*DENOMINATOR/NUMERATOR

    IF (R.LE.V) THEN
        EU=X-X_BAR
        DU=EU-BETA*(FX-FX_BAR)
        ALPH=UPDATE_ALPH(EU,DU,BETA,LAMA)
        CALL PROJECTION(X_BAR,X,FX_BAR,ALPH,FIRSTOUT,LASTOUT)
        X=X_BAR
        XFA_OLD=XFA
        CALL CAL_FX(X,FX,XFA,FIRSTOUT,LASTOUT)

        SUBCOUNTER = SUBCOUNTER + 1
        CALL NCP_ERROR(ERR,XFA,FX)
        CALL ERROR_EUCLIDEAN_DISTANCE(XFA,XFA_OLD,NL,NDEST,DISTANCEERR)
        CALL CPU_TIME(ET)
        SOLC = SOLC + 1
        !WRITE(*,'(I4,2X,F14.6,2X,F10.6)') SOLC,ERR,DISTANCEERR
        WRITE(7,'(I3,A,I4,A,F14.6,A,F14.6)') CASEINDEX,',', SOLC,',',ERR,',',DISTANCEERR
        !WRITE(7,'(I4,2X,F14.6,2X,F10.6)') SOLC,ERR,DISTANCEERR
        !		WRITE(7,'(F8.6,2X,F8.4)') ET - ST , ERR
        IF (R.LE.MIU) BETA=BETA/BETASTEP
        !	WRITE(*,*) CT,BETA,ERR
        !	IF (PITER.GT.10D3) GOTO 1000
        IF ((SOLC.GE.MACSOLC).OR.(ERR<=NCP_EPS).OR.(SUBCOUNTER.GT.SUBMAX)) GOTO 1000
        IF (ERR>NCP_EPS) GOTO 10
    END IF
    ! STEP 3
998    X=X_BAR
    FX=FX_BAR
    IF (ERR<=NCP_EPS.OR.SOLC.GE.MACSOLC) GOTO 1000
    BETA=BETASTEP*BETA*MIN(1.0,(1.0/R))
    GOTO 10

1000 CALL CPU_TIME(TIME_END)
    CPUTIME=TIME_END-TIME_BEGIN
    DEL = .TRUE.
    CALL UPDATESUB(STT,DEL,XFA)
    IF (.NOT.UECONVERGE) THEN
        SUBCOUNTER = 0.0
        CALL BACKWARD_UPDATE_FX(FX,STT)
        GO TO 10
    ELSE
        IF (ERR<=NCP_EPS.OR.(SOLC.GT.MACSOLC)) THEN
            IF (ERR<=NCP_EPS) THEN
                ISCONVERGE = .TRUE.
            ENDIF
                CALL BACKWARD_UPDATE_FX(FX,STT)
                CALL OUTPUTOD(XFA,FX)
                CALL OUTPUTPATH(STT,XFA)
            CLOSE(7)
            RETURN
        ELSE
            GO TO 10
        END IF
    END IF


    CLOSE(7)
    END SUBROUTINE

    SUBROUTINE NODE_FLOW(XFA)
    ! GIVEN ARF FLOW GET NODE FLOW
    USE  GRAPH
    IMPLICIT NONE
    INTEGER L
    INTEGER NR
    REAL*8,INTENT(IN)::XFA(NL,NDEST)

    NF=0.0
    DO NR=1,NDEST
        DO L =1,NL
            NF(ANODE(L),NR) = NF(ANODE(L),NR)+XFA(L,NR)
        END DO
    END DO


    RETURN
    END SUBROUTINE


    SUBROUTINE PROJECTION(X1,X0,FX0,ALPH,FIRSTOUT,LASTOUT)
    USE  GRAPH
    IMPLICIT NONE
    INTEGER,PARAMETER::MAX_OUT_LINKS=50
    INTEGER::I,N,J,NR,NODE
    REAL*8,INTENT(IN)::X0(NL,NDEST)
    INTEGER,INTENT(IN)::FIRSTOUT(NN),LASTOUT(NN)
    REAL*8,INTENT(OUT)::X1(NL,NDEST)
    REAL*8::ALPH
    REAL*8,INTENT(IN)::FX0(NL,NDEST)
    REAL*8::PROJ_VECTOR(MAX_OUT_LINKS),PROJ_RESULT(MAX_OUT_LINKS)
    REAL*8::CONST=1.0
    ! FIND MAX OUT LINKS
    PITER=PITER+1
    X1=0.0

    DO NR=1,NDEST
        DO I=1,NN
            IF (TORDER(I,NR)/=0.AND.TORDER(I,NR)/=ROOTS(NR)) THEN
                NODE=TORDER(I,NR)
                PROJ_VECTOR=0.0
                PROJ_RESULT=0.0
                N=0
                DO J=FIRSTOUT(NODE),LASTOUT(NODE)
                    IF (SUBLINK(J,NR)) THEN
                        N = N + 1
                        PROJ_VECTOR(N)=X0(J,NR)-ALPH*FX0(J,NR)
                    END IF
                ENDDO
                CALL SIMPLEX_PROJECTION(PROJ_RESULT,PROJ_VECTOR,CONST,N)
                N = 0
                DO J=FIRSTOUT(NODE),LASTOUT(NODE)
                    IF (SUBLINK(J,NR)) THEN
                        N=N+1
                        X1(J,NR)=PROJ_RESULT(N)
                    END IF
                END DO
            END IF
        ENDDO
    END DO

    RETURN
    END SUBROUTINE

    REAL*8 FUNCTION UPDATE_ALPH(EU,DU,BETA,LAMA)
    USE DEFINE
    IMPLICIT NONE
    REAL*8::EU(NL,NDEST),DU(NL,NDEST),BETA,LAMA
    INTEGER I,J
    REAL*8::UP,DOWN
    REAL*8::NORM_VALUE0
    UP=0.0
    DOWN=0.0
    DO I=1,NDEST
        DO J=1,NL
            UP=UP+EU(J,I)*DU(J,I)
        END DO
    END DO
    DOWN=NORM_VALUE0(DU,NL,NDEST)
    DOWN=DOWN**2
    UPDATE_ALPH=LAMA*BETA*UP/DOWN

    RETURN
    END FUNCTION



