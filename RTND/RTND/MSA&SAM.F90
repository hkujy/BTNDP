! This subroutine is to provide MSA update scheme
SUBROUTINE MSA2(X0,Y0,X1,STEPSIZE,N1,N2) ! TWO DIMENSION MSA
IMPLICIT NONE
! X0 IS INPUT AND ALSO OUTPUT
INTEGER,INTENT(IN)::N1,N2! TWO DIMENSION
REAL*8,INTENT(IN)::Y0(N1,N2)
REAL*8,INTENT(IN)::X0(N1,N2)
REAL*8,INTENT(OUT)::X1(N1,N2)
REAL*8,INTENT(IN)::STEPSIZE
INTEGER:: I,J

X1=0.0
DO I=1,N2
	DO J=1,N1
		X1(J,I)=X0(J,I)+STEPSIZE*(Y0(J,I)-X0(J,I))
	ENDDO 
ENDDO 

RETURN 
END SUBROUTINE 

SUBROUTINE SELF_REGULATED_MSA(X0,X1,Y0,Y1,X2,N1,N2,B0,INCREA1,INCREA2,CONVERGE,MSA_ERROR)
IMPLICIT NONE 
! SELF -REGUATED MSA 
! reference
! metod of successive weighted averages
! and self-regulated averaging schemes for 
!solving stochasitic user euqiblibrium problem
! Netw Spat Ecom (2009)
! NOTATIONS 
! X0,Y0,INPUT VAIRABLES
! X1,Y1,OUTPUT VARIABLES 
! N1,N2 DIMENSION
! B0 IS TO DETEMINE STEPSIZE 
! B0 WILL UPDATE AFTER
! INCRE1 IS >1 INCREMENT
! INCRE2 IS <1 INCREMENT 
! X1 WII BE THE NEW UPDATE RESULTS 
	INTEGER,INTENT(IN)::N1,N2
	REAL*8,INTENT(IN)::X0(N1,N2),Y0(N1,N2),Y1(N1,N2)
	REAL*8,INTENT(IN)::X1(N1,N2)
	REAL*8,INTENT(OUT)::X2(N1,N2)
	REAL*8,INTENT(INOUT)::B0
	REAL*8,INTENT(IN)::INCREA1,INCREA2
	REAL*8,INTENT(OUT)::MSA_ERROR
	REAL*8 STOP_EPS,DISTANCE0,DISTANCE1
	REAL*8 STEPSIZE
	INTEGER I,J
	LOGICAL::CONVERGE

	CONVERGE=.FALSE.
	MSA_ERROR=0.0
	X2=0.0

	STOP_EPS=0.000001
	DISTANCE0=0.0
	DISTANCE1=0.0
	DO I=1,N1
		DO J=1,N2
			DISTANCE1=DISTANCE1+(X1(i,j)-Y1(i,j))**2
			DISTANCE0=DISTANCE0+(X0(i,j)-Y0(i,j))**2
		ENDDO 
	ENDDO 
	DISTANCE1=SQRT(DISTANCE1)
	DISTANCE0=SQRT(DISTANCE0)
	MSA_ERROR=DISTANCE1
	IF (DISTANCE1<STOP_EPS) THEN 
		WRITE(*,*) "CONVERGE AND STOP ITERATION"
		CONVERGE=.TRUE.
		X2=Y1  ! IF CONVERGE THEN RETUN THE FX FROM LAST ITERATION AS NEW
		RETURN 
	END IF 
	
	IF (DISTANCE1.GT.DISTANCE0) THEN 
		B0=B0+INCREA1
	ELSE 
		B0=B0+INCREA2
	ENDIF 
	STEPSIZE=1/B0
	CALL MSA2(X1,Y1,X2,STEPSIZE,N1,N2)
	
	RETURN 
	END SUBROUTINE 

